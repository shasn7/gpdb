-- enable resource group and restart cluster.
-- start_ignore
! gpconfig -c gp_resource_manager -v group;
! gpconfig -c runaway_detector_activation_percent -v 100;
! gpstop -rai;
-- end_ignore

SHOW gp_resource_manager;

CREATE OR REPLACE VIEW memory_result2 AS
SELECT rsgname, ismaster, avg(memory_usage) AS avg_mem
FROM(
        SELECT rsgname,
               CASE (j->'key')::text WHEN '"-1"'::text THEN 1 ELSE 0 END AS ismaster,
               ((j->'value')->>'used')::int AS memory_usage
        FROM(
                SELECT rsgname, row_to_json(json_each(memory_usage::json)) AS j FROM
                    gp_toolkit.gp_resgroup_status
                WHERE rsgname='test_group'
            )a
    )b GROUP BY (rsgname, ismaster) ORDER BY rsgname, ismaster;

CREATE OR REPLACE FUNCTION resGroupPalloc(float) RETURNS int AS
'@abs_builddir@/../regress/regress@DLSUFFIX@', 'resGroupPalloc'
LANGUAGE C READS SQL DATA;

alter resource group default_group set memory_limit 10;
alter resource group admin_group set memory_limit 80;

-- set concurrency=1 to make calculations trivial
create resource group test_group with (concurrency=1, memory_limit=10, memory_spill_ratio=100, cpu_rate_limit=20);
create role test_role resource group test_group;

select * from gp_toolkit.gp_resgroup_config;

0: set role test_role;
-- first allocation consumes all group memory, resGroupPalloc considers
-- startup memory when this function is used for the first time and 
-- subs it from requested memory
0: select resGroupPalloc(1.0) from gp_dist_random('gp_id') where gp_segment_id = 1;
select * from memory_result2;

-- second allocation fails
0: select resGroupPalloc(0.01) from gp_dist_random('gp_id') where gp_segment_id = 1;
select * from memory_result2;
0q:

create table t1 (a int, b int) distributed by(a);
grant select on t1 to test_role;

alter resource group test_group set concurrency 20;

1: set role test_role;
1: begin;
1: select count(*) from t1;
select * from memory_result2;

2: set role test_role;
2: begin;
2: select count(*) from t1;
select * from memory_result2;

3: set role test_role;
3: begin;
3: select count(*) from t1;
select * from memory_result2;

4: set role test_role;
4: begin;
4: select count(*) from t1;
select * from memory_result2;

5: set role test_role;
5: begin;
5: select count(*) from t1;
select * from memory_result2;

6: set role test_role;
6: begin;
6: select count(*) from t1;
select * from memory_result2;

7: set role test_role;
7: begin;
7: select count(*) from t1;
select * from memory_result2;

8: set role test_role;
8: begin;
8: select count(*) from t1;
select * from memory_result2;

9: set role test_role;
9: begin;
9: select count(*) from t1;
select * from memory_result2;

10: set role test_role;
10: begin;
10: select count(*) from t1;
select * from memory_result2;

11: set role test_role;
11: begin;
11: select count(*) from t1;
select * from memory_result2;

12: set role test_role;
12: begin;
12: select count(*) from t1;
select * from memory_result2;

13: set role test_role;
13: begin;
13: select count(*) from t1;
select * from memory_result2;

14: set role test_role;
14: begin;
14: select count(*) from t1;
select * from memory_result2;

1q:
2q:
3q:
4q:
5q:
6q:
7q:
8q:
9q:
10q:
11q:
12q:
13q:
14q:

alter resource group admin_group reset memory_limit;
alter resource group default_group reset memory_limit;

set role none;
drop table t1;
drop role test_role;
drop resource group test_group;

-- start_ignore
! gpstop -rai;
-- end_ignore
