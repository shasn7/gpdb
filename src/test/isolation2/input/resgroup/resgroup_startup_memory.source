-- enable resource group and restart cluster.
-- start_ignore
! gpconfig -c gp_resource_manager -v group;
! gpconfig -c runaway_detector_activation_percent -v 100;
! gpstop -rai;
-- end_ignore

SHOW gp_resource_manager;

CREATE OR REPLACE FUNCTION resGroupPalloc(float) RETURNS int AS
'@abs_builddir@/../regress/regress@DLSUFFIX@', 'resGroupPalloc'
LANGUAGE C READS SQL DATA;

select * from gp_toolkit.gp_resgroup_config;

alter resource group default_group set memory_limit 10;
alter resource group admin_group set memory_limit 70;

-- set concurrency=1 to make calculations trivial
create resource group test_group with (concurrency=1, memory_limit=20, memory_spill_ratio=100, cpu_rate_limit=20);
create role test_role resource group test_group;

0: set role test_role;
-- first allocation consumes all group memory, resGroupPalloc considers
-- startup memory when this function is used for the first time and 
-- subs it from requested memory
0: select resGroupPalloc(1.0) from gp_dist_random('gp_id') where gp_segment_id = 1;

-- second allocation fails
0: select resGroupPalloc(0.01) from gp_dist_random('gp_id') where gp_segment_id = 1;
0q:

create table t1 (a int, b int) distributed by(a);
grant select on t1 to test_role;

alter resource group test_group set concurrency 20;

1: set role test_role;
1: begin;
1: select count(*) from t1;

2: set role test_role;
2: begin;
2: select count(*) from t1;

3: set role test_role;
3: begin;
3: select count(*) from t1;

4: set role test_role;
4: begin;
4: select count(*) from t1;

5: set role test_role;
5: begin;
5: select count(*) from t1;

6: set role test_role;
6: begin;
6: select count(*) from t1;

7: set role test_role;
7: begin;
7: select count(*) from t1;

1q:
2q:
3q:
4q:
5q:
6q:
7q:

alter resource group admin_group set memory_limit 10;

set role none;
drop table t1;
drop role test_role;
drop resource group test_group;

-- start_ignore
! gpstop -rai;
-- end_ignore
